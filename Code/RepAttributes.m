intrinsic order(M::LMFDBRepCC) -> FldRatElt
  {Return order of the group}
  return Order(M`MagmaGrp);
end intrinsic;

intrinsic dim(M::LMFDBRepCC) -> FldRatElt
  {Return the dimension of the representation}
  return Dimension(M`MagmaRep);
end intrinsic;

intrinsic irreducible(M::LMFDBRepCC) -> FldRatElt
  {Return true if the representation is irreducible; false otherwise.}
  return IsIrreducible(M`MagmaRep);
end intrinsic;

intrinsic indicator(M::LMFDBRepCC) -> FldRatElt
  {Computes the Frobenius-Schur indicator}
  Mat := M`MagmaGrp;
  ind := 0;
  for g in Mat do
    ind +:= Trace(g^2);
  end for;
  return Integers() ! (ind/Get(M,"order"));
end intrinsic;

intrinsic cyc_order_mat(M::LMFDBRepCC) -> RngIntElt
  {an integer m so that the entries in the gens column lie in CyclotomicField(m)}
  MM := M`MagmaRep;
  MMmin := AbsoluteModuleOverMinimalField(MM);
  rng:= CoefficientRing(MMmin);
  if rng eq Rationals() then return 1; end if;
  if Type(rng) eq FldCyc then return Conductor(rng); end if;
  return Norm(Conductor(AbelianExtension(rng)));
end intrinsic;

intrinsic schur_index(M::LMFDBRepCC) -> RngIntElt
  {Returns the ratio of the minimal degree of a number field containing all matrix entries by the degree of the number field generated by the traces}
  m := Get(M, "cyc_order_mat");
  n := Get(M, "cyc_order_traces");
  assert m mod n eq 0;
  return m div n;
end intrinsic;

intrinsic AbsoluteModuleOverMinimalField(~M::LMFDBRepCC)
  {Assign to M`MagmaRep the absolutely irreducible module M over the smallest possible field without increasing the dimension of the module. Also assign M`MagmaGrp to be the corresponding group.}
  MM := M`MagmaRep;
  MMmin := AbsoluteModuleOverMinimalField(MM);
  M`MagmaRep := MMmin;
  M`MagmaGrp := MatrixGroup(MMmin);
  print "Module over minimal field computed and assigned";
end intrinsic;

intrinsic recog(u::SeqEnum, v::SeqEnum : AllowS:=false) -> BoolElt, RngIntElt, RngIntElt
  {See if there exist integers r,s such that u = r*v+s.  Inputs are vectors
   of coefficients from elements of a cyclotomic field.  1st entry is the
   coefficient of 1.  Return is yes/no, r, s}
  k:=  AllowS select 2 else 1;
  Z := Integers();
  while u[k] eq 0 and v[k] eq 0 do
    k:= k+1;
  end while;
  if u[k] eq 0 or v[k] eq 0 then
    return false, 0, 0;
  end if;
  // Now have first non-zero place
  r := (Z ! u[k]) div (Z ! v[k]);
  for j:=k to #u do
    if u[j] ne r*v[j] then return false, 0, 0; end if;
  end for;
  s:= u[1] - r*v[1];
  return true, r, (Z ! s);
end intrinsic;

// Temporarily still here for comparison to debug the newer version below
intrinsic oldWriteCyclotomicElement(u::FldCycElt) -> SeqEnum
  {Given an element u of a cyclotomic field with primitive root zeta_m, return a SeqEnum of pairs [c,e] such that
  u is the sum of c*zeta_m^e}
  //K<z> := CyclotomicField(Conductor(Parent(u)) : Sparse := false);
  K<z> := CyclotomicField(CyclotomicOrder(Parent(u)) : Sparse := false);
  m := CyclotomicOrder(K);
  u_seq := Eltseq(K!u);
  if IsPrime(m) then
    u_seq := u_seq cat [0];
    cnt:=0;
    for j in u_seq do if j ne 0 then cnt +:=1; v:=j; end if; end for;
    if cnt gt m/2 then
      for j:=1 to #u_seq do u_seq[j] -:= v; end for;
    end if;
  end if;
  cs := [];
  for i := 1 to #u_seq do
    if u_seq[i] ne 0 then
      e := i-1;
      if e gt Floor(m/2) then // want e in range -m/2 < e <= m/2
        e := e - m;
      end if;
      assert (-m/2 lt e) and (e lt m/2); // should second lt be le?
      Append(~cs, [u_seq[i], e]);
    end if;
  end for;
  if cs eq [] then return [[0,0]]; end if;
  return cs;
end intrinsic;

// TODO: not quite right format...see propose schema
intrinsic WriteCyclotomicElement(u::FldCycElt) -> SeqEnum
  {Given an element u of a cyclotomic field with primitive root zeta_m, return a SeqEnum of pairs [c,e] such that
  u is the sum of c*zeta_m^e}
  //K<z> := CyclotomicField(Conductor(Parent(u)) : Sparse := false);
  K<z> := CyclotomicField(CyclotomicOrder(Parent(u)) : Sparse := false);
  m := CyclotomicOrder(K);
  u_seq := Eltseq(K!u);   // j-th element is for zeta^(j-1)
  // Check if it is just an integer
  is_int:=true; j:=2;
  while is_int and j le #u_seq do
    is_int := u_seq[j] eq 0;
    j +:= 1;
  end while;
  if is_int then return [[u_seq[1], 0]]; end if;
  is_found:=false;
  // Test for r*(zeta^j+zeta^(-j)
  for j:=1 to (m-1) div 2 do
    v := Eltseq(K! z^j+z^(-j));
    tf, r, s := recog(u_seq, v);
    //"Try ", j, " with ", u_seq, " and ", v, " got ", tf;
    if tf then
      new_u := [0 : k in [1..m]];
      new_u[1] := s;
      new_u[j+1] := r;
      new_u[m-j+1] := r;
      u_seq := new_u;
      is_found:=true;
      break;
    end if;
  end for;
  // Test for r*zeta^j
  for j:=1 to m-1 do
    if is_found then break; end if; // Avoids nesting for skipping loop
    v := Eltseq(K! z^j);
    tf, r, s := recog(u_seq, v);
    //"Try ", j, " with ", u_seq, " and ", v, " got ", tf;
    if tf then
      new_u := [0 : k in [1..m]];
      new_u[1] := s;
      new_u[j+1] := r;
      u_seq := new_u;
      is_found:=true;
      break;
    end if;
  end for;
  if #u_seq lt m then u_seq := u_seq cat [0 : j in [1..(m-#u_seq)]]; end if;

  u_seqold:=u_seq;        // For debugging
  divlist:= Divisors(m);
  halves:=[]; // values where we hit half the elements
  // Count coeffs for each Galois orbit
  // Alist[j] has counters for orbit of zeta^divlist[j], elements with
  //   order m/divlist[j]
  Alist := [AssociativeArray() : d in divlist];
  for j:=1 to #u_seq do
    if u_seq[j] ne 0 then
      posn:=Position(divlist, GCD(j-1,m));
      Alist[posn]:=inc_counter(Alist[posn], u_seq[j]);
    end if;
  end for;
  // Tr(zeta_n)= (-1)^#(primes dividing n) if n is squarefree, else 0
  for j:=1 to #divlist-1 do  // last divlist is order 1
    d := divlist[j];
    posn:=Position(divlist, d);
    cnts := Alist[posn];
    my_order:=EulerPhi(m div d);
    for ky in Keys(cnts) do
//"m=",m,"key=",ky,"count=",cnts[ky],"m/d=", m div d,"my order=", my_order;
      if 2*cnts[ky] gt my_order then
        for ell:=1 to m div d do
          if GCD(ell, m div d) eq 1 then
            u_seq[ell*d+1] -:= ky;
          end if;
        end for;
        u_seq[1] +:= MoebiusMu(m div d) * ky;
      elif 2*cnts[ky] eq my_order then
        Append(~halves, [j, ky, cnts[ky]]);
      end if;
    end for;
  end for;
  //u_seqold, "and", u_seq;

  cs := [];
  for i := 1 to #u_seq do
    if u_seq[i] ne 0 then
      e := i-1;
      if e gt Floor(m/2) then // want e in range -m/2 < e <= m/2
        e := e - m;
      end if;
      assert (-m/2 lt e) and (e lt m/2); // should second lt be le?
      Append(~cs, [u_seq[i], e]);
    end if;
  end for;
  if cs eq [] then return [[0,0]]; end if;
  return cs;
end intrinsic;

intrinsic ReadCyclotomicElement(cs::SeqEnum, m::RngIntElt) -> FldCycElt
  {Given a SeqEnum of pairs representing a cyclotomic field element as in the output of WriteCyclotomicElement, construct t    he corresponding cyclotomic field element.}
  K<z> := CyclotomicField(m : Sparse := false);
  u := K!0; for pair in cs do
    e := Integers()!pair[2];
    u +:= pair[1]*z^e;
  end for;
  return u, K;
end intrinsic;

intrinsic CyclotomizeMatrixGroup(M::GrpMat) -> Any
  {Given a matrix group over an abelian number field, change the universe to a containing cyclotomic field}
  e := Exponent(M);
  if e mod 4 eq 2 then
    e := e div 2;
  end if;
  K<z> := CyclotomicField(e : Sparse := false);
  return ChangeRing(M,K);
end intrinsic;

intrinsic IntegralizeMatrix(M::Any) -> Any
//intrinsic IntegralizeMatrix(M::AlgMatElt) -> Any
  {Given a matrix return a matrix with integral entries, along with a common denominator}
  d := 1;
  for i := 1 to Nrows(M) do
    for j := 1 to Ncols(M) do
      d := Lcm(d, Denominator(M[i,j]));
    end for;
  end for;
  q:=[[d*M[i,j] : i in [1..Nrows(M)]] : j in [1..Ncols(M)]];
  M1:= Matrix(Parent(M[1,1]),Nrows(M), Ncols(M),q);
  return M1, d;
  //return d*M, d;
end intrinsic;

//intrinsic WriteCyclotomicMatrix(M::GrpMatElt) -> SeqEnum
intrinsic WriteCyclotomicMatrix(M::Any) -> SeqEnum
  {Given a matrix over a cyclotomic field, return a SeqEnum whose entries are integral and of the form given by WriteCyclotomicElement.}
  M_seq := [];
  for row in Rows(M) do
    Append(~M_seq, [WriteCyclotomicElement(el) : el in Eltseq(row)]);
  end for;
  return M_seq;
end intrinsic;

intrinsic ReadCyclotomicMatrix(cs::SeqEnum, m::RngIntElt) -> GrpMatElt
  {Given a SeqEnum as in the output of WriteCyclotomicMatrix, return the corresponding matrix}
  K<z> := CyclotomicField(m : Sparse := false);
  rows := [];
  for r in cs do
    Append(~rows, [ReadCyclotomicElement(el,m) : el in r]);
  end for;
  return Matrix(K,rows);
end intrinsic;

intrinsic WriteIntegralMatrix(M::Any) -> SeqEnum
  {Given a matrix over a Z, return a SeqEnum.}
  return [ [el : el in Eltseq(row)] : row in Rows(M)];
end intrinsic;

intrinsic ReadIntegralMatrix(cs::SeqEnum) -> Any
  {Read a matrix over a Z, as a SeqEnum of rows}
  return Matrix(Integers(), cs);
end intrinsic;


intrinsic carat_label(G::LMFDBRepQQ) -> Any
  {Return the CARAT label for a repn of dimension < 7.  Will be computed by
   other software.}
  return None();
end intrinsic;

intrinsic order(H::LMFDBRepQQ) -> Any
  {The size of the group}
  return Order(H`MagmaGrp);
end intrinsic;

intrinsic group(H::LMFDBRepQQ) -> Any
  {returns the LMFDB id for the abstract group}
  return label(H`MagmaGrp);
end intrinsic;


intrinsic order(H::LMFDBRepZZ) -> Any
  {The size of the group}
  return Order(H`MagmaGrp);
end intrinsic;

intrinsic group(H::LMFDBRepZZ) -> Any
  {returns the LMFDB id for the abstract group}
  return label(H`MagmaGrp);
end intrinsic;
